#!/usr/bin/python3
"""
Merge SBOM files from different sources.

Expects SBOM created from konflux buildroots and syft-generated one. It will
take the first one and extend it with data from syft.
"""

import argparse
import hashlib
import json
import logging
import subprocess


def get_params():
    """Parse command-line arguments for SBOM merging.

    :returns: Parsed command-line arguments
    :rtype: argparse.Namespace
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--sbom-spdx', required=True, help="SPDX SBOM generated by pipeline")
    parser.add_argument('--syft-sbom', required=True, help="SPDX SBOM generated by Syft")
    parser.add_argument('--sbom-merged', required=True, help="Output SPDX SBOM file")
    parser.add_argument('--source-data', help="JSON file with source data from gen_ancestors_from_src.py")
    parser.add_argument(
        '--mock-lockfile',
        action='append',
        help="Path to Mock lockfile for buildroot packages (can be specified multiple times)"
    )
    args = parser.parse_args()
    return args


def get_generic_purl(name, version=None, url=None, checksum=None, alg=None):
    """Generate Package URL (purl) for a source package."""
    purl = f"pkg:generic/{name}"
    if version:
        purl += f"@{version}"
    if url:
        purl += f"?download_url={url}"
    if checksum:
        purl += f"&checksum={alg.lower() if alg else 'sha256'}:{checksum}"
    return purl


def get_rpm_purl(name, version, release, arch, epoch=None):
    """Generate Package URL (purl) for an RPM package.

    :param name: Package name
    :type name: str
    :param version: Package version
    :type version: str
    :param release: Package release
    :type release: str
    :param arch: Package architecture
    :type arch: str
    :param epoch: Package epoch (optional)
    :type epoch: str or None
    :returns: RPM purl string
    :rtype: str
    """
    # Format: pkg:rpm/redhat/name@version-release?arch=...
    version_str = f"{version}-{release}"
    if epoch:
        version_str = f"{epoch}:{version_str}"

    purl = f"pkg:rpm/redhat/{name}@{version_str}?arch={arch}"
    return purl


def convert_rpm_license_to_spdx(rpm_license):
    """Convert RPM license to SPDX license expression using license-fedora2spdx.

    :param rpm_license: RPM license string
    :type rpm_license: str
    :returns: SPDX license expression, or "NOASSERTION" if conversion fails
    :rtype: str
    """
    if not rpm_license:
        return "NOASSERTION"

    try:
        result = subprocess.run(
            ["license-fedora2spdx", rpm_license],
            capture_output=True,
            text=True,
            check=True,
            timeout=5
        )
        spdx_license = result.stdout.strip()
        return spdx_license if spdx_license else "NOASSERTION"
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError) as e:
        logging.warning("Failed to convert license '%s' to SPDX: %s", rpm_license, e)
        return "NOASSERTION"


def attach_sources(sbom_root, source_data_file):
    """
    Add source packages from gen_ancestors_from_src.py output to SBOM.

    For each source in the source data file:
    - Creates a source package (SPDXRef-Source{idx}) with midstream url
    - Includes upstream checksum in the source package checksums
    - Generates purl using midstream URL and checksum
    - Adds CONTAINS relationship from SRPM to the source package
    - If upstream URL exists, creates an origin package (SPDXRef-Source{idx}-origin)
      with upstream properties and adds GENERATED_FROM relationship

    :param sbom_root: The root SBOM dictionary to modify, which contains (S)RPMs data
    :param source_data_file: Path to JSON file with source data from gen_ancestors_from_src.py
    """
    with open(source_data_file, encoding="utf-8") as f:
        source_data = json.load(f)
    sources = source_data.get('sources', [])

    # Add source packages to SBOM
    for idx, source in enumerate(sources):
        # Set properties based on whether midstream exists
        midstream = source.get("midstream", {})
        # Create source package
        source_pkg = {
            "SPDXID": f"SPDXRef-Source{idx}",
            "name": source["name"],
            "versionInfo": source.get("version", "unknown"),
            "packageFileName": source["filename"],
            "downloadLocation": midstream.get("url", "NOASSERTION"),
            "filesAnalyzed": False,
            "checksums": [
                # use source.checksum
                {
                    "algorithm": source["alg"],
                    "checksumValue": source["checksum"]
                }
            ],
            "externalRefs": [
                # Add purl using midstream URL and checksum
                {
                    "referenceCategory": "PACKAGE-MANAGER",
                    "referenceType": "purl",
                    "referenceLocator": get_generic_purl(
                        name=source["name"],
                        version=source.get("version"),
                        url=midstream.get("url"),
                        checksum=midstream.get("checksum"),
                        alg=midstream.get("alg")
                    )
                }
            ],
        }

        sbom_root["packages"].append(source_pkg)
        sbom_root.setdefault("relationships", []).append(
            {
                "spdxElementId": "SPDXRef-SRPM",
                "relationshipType": "CONTAINS",
                "relatedSpdxElement": f"SPDXRef-Source{idx}",
            }
        )
        # Create upstream origin package if upstream exists
        if source.get("url"):
            upstream_pkg = {
                "SPDXID": f"SPDXRef-Source{idx}-origin",
                "name": source["name"],
                "versionInfo": source.get("version", "unknown"),
                "downloadLocation": source.get("url"),
                "packageFileName": source["filename"],
                "filesAnalyzed": False,
            }

            # Add upstream checksum if available
            if source.get("checksum") and source.get("alg"):
                upstream_pkg["checksums"] = [{
                    "algorithm": source["alg"],
                    "checksumValue": source["checksum"]
                }]

            # Add purl as external reference
            upstream_pkg["externalRefs"] = [{
                "referenceCategory": "PACKAGE-MANAGER",
                "referenceType": "purl",
                "referenceLocator": get_generic_purl(
                    name=source["name"],
                    version=source.get("version"),
                    url=source.get("url"),
                    checksum=source.get("checksum"),
                    alg=source.get("alg")
                )
            }]

            sbom_root['packages'].append(upstream_pkg)

            # Add relationship: midstream GENERATED_FROM upstream
            sbom_root['relationships'].append({
                "spdxElementId": f"SPDXRef-Source{idx}",
                "relationshipType": "GENERATED_FROM",
                "relatedSpdxElement": f"SPDXRef-Source{idx}-origin",
            })


def attach_buildroot_packages(sbom_root, mock_lockfiles, srpm_name):
    """
    Add buildroot packages from mock lockfiles to SBOM.

    For each mock lockfile:
    - Parse the buildroot.rpms list
    - Extract config.target_arch to identify build environment
    - Create a virtual buildroot package per architecture
    - Create SPDX packages for each buildroot RPM
    - Add CONTAINS relationships from virtual package to buildroot RPMs
    - Add BUILD_TOOL_OF relationships from virtual package to binary RPMs

    :param sbom_root: The root SBOM dictionary to modify
    :type sbom_root: dict
    :param mock_lockfiles: List of paths to mock lockfile JSON files
    :type mock_lockfiles: list
    :param srpm_name: Name of the SRPM being built (for virtual package naming)
    :type srpm_name: str
    """
    if not mock_lockfiles:
        return

    for lockfile_path in mock_lockfiles:
        with open(lockfile_path, encoding="utf-8") as f:
            lockfile_data = json.load(f)

        # Extract target architecture from config
        target_arch = lockfile_data.get("config", {}).get("target_arch")
        if not target_arch:
            logging.warning("No target_arch found in lockfile %s, skipping", lockfile_path)
            continue

        # Create virtual buildroot package for this architecture
        # Calculate a unique version identifier (hash of lockfile path)
        lockfile_hash = hashlib.sha256(lockfile_path.encode()).hexdigest()[:8]

        virtual_spdx_id = f"SPDXRef-Buildroot-{srpm_name}-{target_arch}"
        virtual_pkg = {
            "SPDXID": virtual_spdx_id,
            "name": f"{srpm_name}-buildroot-{target_arch}",
            "versionInfo": lockfile_hash,
            "downloadLocation": "NOASSERTION",
            "filesAnalyzed": False,
        }
        sbom_root["packages"].append(virtual_pkg)

        # Get buildroot RPMs
        buildroot_rpms = lockfile_data.get("buildroot", {}).get("rpms", [])

        for rpm in buildroot_rpms:
            # Create unique SPDXID using rpm name and arch
            # Format: SPDXRef-Buildroot-Package-{rpm_name}-{arch}
            spdx_id = f"SPDXRef-Buildroot-Package-{rpm['name']}-{target_arch}"

            # Build version string (version-release)
            version_str = f"{rpm['version']}-{rpm['release']}"
            if rpm.get('epoch'):
                version_str = f"{rpm['epoch']}:{version_str}"

            # Convert RPM license to SPDX license expression
            rpm_license = rpm.get("license")
            spdx_license = convert_rpm_license_to_spdx(rpm_license)

            # Create buildroot package
            buildroot_pkg = {
                "SPDXID": spdx_id,
                "name": rpm["name"],
                "versionInfo": version_str,
                "downloadLocation": rpm.get("url", "NOASSERTION"),
                "licenseDeclared": spdx_license,
                "filesAnalyzed": False,
                "supplier": "Organization: Red Hat",
            }

            # Add checksum if sigmd5 is available
            if rpm.get("sigmd5"):
                buildroot_pkg["checksums"] = [{
                    "algorithm": "MD5",
                    "checksumValue": rpm["sigmd5"]
                }]

            # Add RPM purl as external reference
            buildroot_pkg["externalRefs"] = [{
                "referenceCategory": "PACKAGE-MANAGER",
                "referenceType": "purl",
                "referenceLocator": get_rpm_purl(
                    name=rpm["name"],
                    version=rpm["version"],
                    release=rpm["release"],
                    arch=rpm["arch"],
                    epoch=rpm.get("epoch")
                )
            }]

            sbom_root["packages"].append(buildroot_pkg)

            # Add CONTAINS relationship from virtual package to buildroot RPM
            sbom_root.setdefault("relationships", []).append({
                "spdxElementId": virtual_spdx_id,
                "relationshipType": "CONTAINS",
                "relatedSpdxElement": spdx_id
            })

        # Find binary RPMs built for this architecture
        # and add BUILD_TOOL_OF relationships from virtual package
        for pkg in sbom_root["packages"]:
            # Check if this is a binary RPM for the target architecture
            # Look for arch={target_arch} in the purl
            if not pkg.get("externalRefs"):
                continue

            purl = pkg["externalRefs"][0].get("referenceLocator", "")
            # Skip buildroot-related packages (virtual and individual buildroot packages)
            spdx_id = pkg.get("SPDXID", "")
            if spdx_id.startswith("SPDXRef-Buildroot-") or spdx_id.startswith("SPDXRef-Buildroot-Package-"):
                continue

            # Check if this is a binary RPM for the target architecture
            if f"arch={target_arch}" in purl and "pkg:rpm/" in purl:
                # Add BUILD_TOOL_OF relationship from virtual buildroot package
                sbom_root.setdefault("relationships", []).append({
                    "spdxElementId": virtual_spdx_id,
                    "relationshipType": "BUILD_TOOL_OF",
                    "relatedSpdxElement": pkg["SPDXID"]
                })


def merge_sboms(root_sbom, syft_sbom, output_sbom, source_data_file=None, mock_lockfiles=None):
    """Merge SPDX SBOMs from different sources into a single output file.

    :param root_sbom: Path to the root SBOM file (from SRPM)
    :type root_sbom: str
    :param syft_sbom: Path to the Syft-generated SBOM file
    :type syft_sbom: str
    :param output_sbom: Path to the output merged SBOM file
    :type output_sbom: str
    :param source_data_file: Optional path to source data JSON from gen_ancestors_from_src.py
    :type source_data_file: str or None
    :param mock_lockfiles: Optional list of paths to mock lockfile JSON files
    :type mock_lockfiles: list or None
    """
    with open(root_sbom, encoding="utf-8") as f:
        sbom_root = json.load(f)
    with open(syft_sbom, encoding="utf-8") as f:
        sbom_syft = json.load(f)

    # https://github.com/RedHatProductSecurity/security-data-guidelines/blob/main/sbom/examples/rpm/build/from-koji.py
    syft_pkgs = sbom_syft.get('packages', [])
    for pkg in syft_pkgs:
        if "externalRefs" not in pkg:
            continue

    sbom_root['packages'].extend(syft_pkgs)
    sbom_root['files'].extend(sbom_syft.get("files", []))
    syft_rels = sbom_syft.get("relationships", [])

    # Adjust top-level relationship to document, to link it into Source0
    # of our sources.
    for relationship in syft_rels:
        if (
            relationship["spdxElementId"] == "SPDXRef-DOCUMENT"
            and relationship["relationshipType"] == "DESCRIBES"
        ):
            relationship["spdxElementId"] = "SPDXRef-Source0"  # pick first one
            relationship["relationshipType"] = "CONTAINS"
    sbom_root['relationships'].extend(syft_rels)

    # Add source data if provided
    if source_data_file:
        attach_sources(sbom_root, source_data_file)

    # Add buildroot packages if mock lockfiles provided
    if mock_lockfiles:
        # Extract SRPM name from the root SBOM document name
        # Format is typically: "package-name-version-release"
        # We want just the package name
        srpm_name = sbom_root.get("name", "unknown").split("-")[0]
        attach_buildroot_packages(sbom_root, mock_lockfiles, srpm_name)

    with open(output_sbom, 'wt', encoding="utf-8") as f:
        json.dump(sbom_root, f)


def _main():
    args = get_params()
    merge_sboms(
        args.sbom_spdx,
        args.syft_sbom,
        args.sbom_merged,
        args.source_data,
        args.mock_lockfile  # This will be a list or None
    )

    # Build output message
    sources_str = ""
    if args.source_data:
        sources_str += f", {args.source_data}"
    if args.mock_lockfile:
        sources_str += f", {len(args.mock_lockfile)} mock lockfile(s)"

    print(f"{args.sbom_spdx} and {args.syft_sbom}{sources_str} merged to {args.sbom_merged}")


if __name__ == "__main__":
    _main()
